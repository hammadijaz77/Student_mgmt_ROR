var e={};class QuickLRU{constructor(e={}){if(!(e.maxSize&&e.maxSize>0))throw new TypeError("`maxSize` must be a number greater than 0");this.maxSize=e.maxSize;this.onEviction=e.onEviction;this.cache=new Map;this.oldCache=new Map;this._size=0}_set(e,t){this.cache.set(e,t);this._size++;if(this._size>=this.maxSize){this._size=0;if("function"===typeof this.onEviction)for(const[e,t]of this.oldCache.entries())this.onEviction(e,t);this.oldCache=this.cache;this.cache=new Map}}get(e){if(this.cache.has(e))return this.cache.get(e);if(this.oldCache.has(e)){const t=this.oldCache.get(e);this.oldCache.delete(e);this._set(e,t);return t}}set(e,t){this.cache.has(e)?this.cache.set(e,t):this._set(e,t);return this}has(e){return this.cache.has(e)||this.oldCache.has(e)}peek(e){return this.cache.has(e)?this.cache.get(e):this.oldCache.has(e)?this.oldCache.get(e):void 0}delete(e){const t=this.cache.delete(e);t&&this._size--;return this.oldCache.delete(e)||t}clear(){this.cache.clear();this.oldCache.clear();this._size=0}*keys(){for(const[e]of this)yield e}*values(){for(const[,e]of this)yield e}*[Symbol.iterator](){for(const e of this.cache)yield e;for(const e of this.oldCache){const[t]=e;this.cache.has(t)||(yield e)}}get size(){let e=0;for(const t of this.oldCache.keys())this.cache.has(t)||e++;return Math.min(this._size+e,this.maxSize)}}e=QuickLRU;var t=e;export default t;

