import e from"nanosocket";import t from"utilise/emitterify";import o from"utilise/values";import n from"utilise/str";var s={};s=function({socket:t=e()}={}){t.id=0;const o=i({socket:t,send:send(t),get subscriptions(){return r(t.on).map(e=>e&&e[0]).filter(e=>e&&e.type&&"$"==e.type[0])}});t.once("disconnected").map(e=>t.on("connected").map(reconnect(o)));t.on("recv").map(deserialise).each(({id:e,data:n})=>{const s=t.on[`$${e}`]&&t.on[`$${e}`][0];n.exec?n.exec(s,n.value):e?t.emit(`$${e}`,n):o.emit("recv",n)});return o};const deserialise=e=>new Function(`return ${e}`)();const reconnect=e=>()=>e.subscriptions.map(({subscription:t})=>e.socket.send(t));const i=t,r=o,c=n;const send=(e,t)=>(o,n)=>{if(o instanceof window.Blob)return binary(e,o,n);const s=c(++e.id),i=e.on(`$${s}`),next=(o,n=0)=>e.send(i.source.subscription=c({id:s,data:o,type:t})).then(e=>i.emit("sent",{id:s,count:n}));o.next?o.map(next).source.emit("start"):next(o);i.source.once("stop").filter(e=>"CLOSED"!=e).map(t=>send(e,"UNSUBSCRIBE")(s).filter((e,t,o)=>o.source.emit("stop","CLOSED")));return i};const binary=(e,t,o,n=0,s=1024)=>{const r=i().on("recv"),next=o=>()=>n>=t.size?r.emit("sent",{id:o}):(e.send(t.slice(n,n+=s)),window.setTimeout(next(o)));send(e,"BINARY")({size:t.size,meta:o}).on("sent",({id:e})=>next(e)()).on("progress",e=>r.emit("progress",{received:e,total:t.size})).map(r.next).source.until(r.once("stop"));return r};var m=s;export default m;

