import e from"buffer";import r from"pump";import t from"stream";var f={};var a=e.Buffer;const{PassThrough:n}=t;f=e=>{e={...e};const{array:r}=e;let{encoding:t}=e;const f="buffer"===t;let o=false;r?o=!(t||f):t=t||"utf8";f&&(t=null);const u=new n({objectMode:o});t&&u.setEncoding(t);let s=0;const c=[];u.on("data",e=>{c.push(e);o?s=c.length:s+=e.length});u.getBufferedValue=()=>r?c:f?a.concat(c,s):c.join("");u.getBufferedLength=()=>s;return u};var o=f;var u={};const{constants:s}=e;const c=r;const g=o;class MaxBufferError extends Error{constructor(){super("maxBuffer exceeded");this.name="MaxBufferError"}}async function getStream(e,r){if(!e)return Promise.reject(new Error("Expected a stream"));r={maxBuffer:Infinity,...r};const{maxBuffer:t}=r;let f;await new Promise((a,n)=>{const rejectPromise=e=>{e&&f.getBufferedLength()<=s.MAX_LENGTH&&(e.bufferedData=f.getBufferedValue());n(e)};f=c(e,g(r),e=>{e?rejectPromise(e):a()});f.on("data",()=>{f.getBufferedLength()>t&&rejectPromise(new MaxBufferError)})});return f.getBufferedValue()}u=getStream;u.default=getStream;u.buffer=(e,r)=>getStream(e,{...r,encoding:"buffer"});u.array=(e,r)=>getStream(e,{...r,array:true});u.MaxBufferError=MaxBufferError;var m=u;const d=u.buffer,B=u.array;const i=u.MaxBufferError;export default m;export{i as MaxBufferError,B as array,d as buffer};

