import e from"http2";import t from"events";import s from"tls";import o from"quick-lru";import n from"stream";import r from"process";import i from"buffer";import a from"http";import h from"https";import c from"resolve-alpn";import u from"net";var l={};const f=t;const m=s;const d=e;const p=o;const g=Symbol("currentStreamsCount");const y=Symbol("request");const S=Symbol("cachedOriginSet");const _=Symbol("gracefullyClosing");const T=["maxDeflateDynamicTableSize","maxSessionMemory","maxHeaderListPairs","maxOutstandingPings","maxReservedRemoteStreams","maxSendHeaderBlockLength","paddingStrategy","localAddress","path","rejectUnauthorized","minDHSize","ca","cert","clientCertEngine","ciphers","key","pfx","servername","minVersion","maxVersion","secureProtocol","crl","honorCipherOrder","ecdhCurve","dhparam","secureOptions","sessionIdContext"];const getSortedIndex=(e,t,s)=>{let o=0;let n=e.length;while(o<n){const r=o+n>>>1;s(e[r],t)?o=r+1:n=r}return o};const compareSessions=(e,t)=>e.remoteSettings.maxConcurrentStreams>t.remoteSettings.maxConcurrentStreams;const closeCoveredSessions=(e,t)=>{for(const s of e)s[S].length<t[S].length&&s[S].every((e=>t[S].includes(e)))&&s[g]+t[g]<=t.remoteSettings.maxConcurrentStreams&&gracefullyClose(s)};const closeSessionIfCovered=(e,t)=>{for(const s of e)t[S].length<s[S].length&&t[S].every((e=>s[S].includes(e)))&&t[g]+s[g]<=s.remoteSettings.maxConcurrentStreams&&gracefullyClose(t)};const getSessions=({agent:e,isFree:t})=>{const s={};for(const o in e.sessions){const n=e.sessions[o];const r=n.filter((e=>{const s=e[Agent.kCurrentStreamsCount]<e.remoteSettings.maxConcurrentStreams;return t?s:!s}));0!==r.length&&(s[o]=r)}return s};const gracefullyClose=e=>{e[_]=true;0===e[g]&&e.close()};class Agent extends f{constructor({timeout:e=6e4,maxSessions:t=Infinity,maxFreeSessions:s=10,maxCachedTlsSessions:o=100}={}){super();this.sessions={};this.queue={};this.timeout=e;this.maxSessions=t;this.maxFreeSessions=s;this._freeSessionsCount=0;this._sessionsCount=0;this.settings={enablePush:false};this.tlsSessionCache=new p({maxSize:o})}static normalizeOrigin(e,t){"string"===typeof e&&(e=new URL(e));t&&e.hostname!==t&&(e.hostname=t);return e.origin}normalizeOptions(e){let t="";if(e)for(const s of T)e[s]&&(t+=`:${e[s]}`);return t}_tryToCreateNewSession(e,t){if(!(e in this.queue)||!(t in this.queue[e]))return;const s=this.queue[e][t];if(this._sessionsCount<this.maxSessions&&!s.completed){s.completed=true;s()}}getSession(e,t,s){return new Promise(((o,n)=>{if(Array.isArray(s)){s=[...s];o()}else s=[{resolve:o,reject:n}];const r=this.normalizeOptions(t);const i=Agent.normalizeOrigin(e,t&&t.servername);if(void 0===i){for(const{reject:e}of s)e(new TypeError("The `origin` argument needs to be a string or an URL object"));return}if(r in this.sessions){const e=this.sessions[r];let t=-1;let o=-1;let n;for(const s of e){const e=s.remoteSettings.maxConcurrentStreams;if(e<t)break;if(s[S].includes(i)){const r=s[g];if(r>=e||s[_]||s.destroyed)continue;n||(t=e);if(r>o){n=s;o=r}}}if(n){if(1!==s.length){for(const{reject:e}of s){const t=new Error(`Expected the length of listeners to be 1, got ${s.length}.\nPlease report this to https://github.com/szmarczak/http2-wrapper/`);e(t)}return}s[0].resolve(n);return}}if(r in this.queue){if(i in this.queue[r]){this.queue[r][i].listeners.push(...s);this._tryToCreateNewSession(r,i);return}}else this.queue[r]={};const removeFromQueue=()=>{if(r in this.queue&&this.queue[r][i]===entry){delete this.queue[r][i];0===Object.keys(this.queue[r]).length&&delete this.queue[r]}};const entry=()=>{const o=`${i}:${r}`;let n=false;try{const a=d.connect(e,{createConnection:this.createConnection,settings:this.settings,session:this.tlsSessionCache.get(o),...t});a[g]=0;a[_]=false;const isFree=()=>a[g]<a.remoteSettings.maxConcurrentStreams;let h=true;a.socket.once("session",(e=>{this.tlsSessionCache.set(o,e)}));a.once("error",(e=>{for(const{reject:t}of s)t(e);this.tlsSessionCache.delete(o)}));a.setTimeout(this.timeout,(()=>{a.destroy()}));a.once("close",(()=>{if(n){h&&this._freeSessionsCount--;this._sessionsCount--;const e=this.sessions[r];e.splice(e.indexOf(a),1);0===e.length&&delete this.sessions[r]}else{const e=new Error("Session closed without receiving a SETTINGS frame");e.code="HTTP2WRAPPER_NOSETTINGS";for(const{reject:t}of s)t(e);removeFromQueue()}this._tryToCreateNewSession(r,i)}));const processListeners=()=>{if(r in this.queue&&isFree())for(const e of a[S])if(e in this.queue[r]){const{listeners:t}=this.queue[r][e];while(0!==t.length&&isFree())t.shift().resolve(a);const s=this.queue[r];if(0===s[e].listeners.length){delete s[e];if(0===Object.keys(s).length){delete this.queue[r];break}}if(!isFree())break}};a.on("origin",(()=>{a[S]=a.originSet;if(isFree()){processListeners();closeCoveredSessions(this.sessions[r],a)}}));a.once("remoteSettings",(()=>{a.ref();a.unref();this._sessionsCount++;if(entry.destroyed){const e=new Error("Agent has been destroyed");for(const t of s)t.reject(e);a.destroy()}else{a[S]=a.originSet;{const e=this.sessions;if(r in e){const t=e[r];t.splice(getSortedIndex(t,a,compareSessions),0,a)}else e[r]=[a]}this._freeSessionsCount+=1;n=true;this.emit("session",a);processListeners();removeFromQueue();0===a[g]&&this._freeSessionsCount>this.maxFreeSessions&&a.close();if(0!==s.length){this.getSession(i,t,s);s.length=0}a.on("remoteSettings",(()=>{processListeners();closeCoveredSessions(this.sessions[r],a)}))}}));a[y]=a.request;a.request=(e,t)=>{if(a[_])throw new Error("The session is gracefully closing. No new streams are allowed.");const s=a[y](e,t);a.ref();++a[g];a[g]===a.remoteSettings.maxConcurrentStreams&&this._freeSessionsCount--;s.once("close",(()=>{h=isFree();--a[g];if(!a.destroyed&&!a.closed){closeSessionIfCovered(this.sessions[r],a);if(isFree()&&!a.closed){if(!h){this._freeSessionsCount++;h=true}const e=0===a[g];e&&a.unref();if(e&&(this._freeSessionsCount>this.maxFreeSessions||a[_]))a.close();else{closeCoveredSessions(this.sessions[r],a);processListeners()}}}}));return s}}catch(e){for(const t of s)t.reject(e);removeFromQueue()}};entry.listeners=s;entry.completed=false;entry.destroyed=false;this.queue[r][i]=entry;this._tryToCreateNewSession(r,i)}))}request(e,t,s,o){return new Promise(((n,r)=>{this.getSession(e,t,[{reject:r,resolve:e=>{try{n(e.request(s,o))}catch(e){r(e)}}}])}))}createConnection(e,t){return Agent.connect(e,t)}static connect(e,t){t.ALPNProtocols=["h2"];const s=e.port||443;const o=e.hostname||e.host;"undefined"===typeof t.servername&&(t.servername=o);return m.connect(s,o,t)}closeFreeSessions(){for(const e of Object.values(this.sessions))for(const t of e)0===t[g]&&t.close()}destroy(e){for(const t of Object.values(this.sessions))for(const s of t)s.destroy(e);for(const e of Object.values(this.queue))for(const t of Object.values(e))t.destroyed=true;this.queue={}}get freeSessions(){return getSessions({agent:this,isFree:true})}get busySessions(){return getSessions({agent:this,isFree:false})}}Agent.kCurrentStreamsCount=g;Agent.kGracefullyClosing=_;l={Agent:Agent,globalAgent:new Agent};var w=l;var C={};const{Readable:E}=n;class IncomingMessage extends E{constructor(e,t){super({highWaterMark:t,autoDestroy:false});this.statusCode=null;this.statusMessage="";this.httpVersion="2.0";this.httpVersionMajor=2;this.httpVersionMinor=0;this.headers={};this.trailers={};this.req=null;this.aborted=false;this.complete=false;this.upgrade=null;this.rawHeaders=[];this.rawTrailers=[];this.socket=e;this.connection=e;this._dumped=false}_destroy(e){this.req._request.destroy(e)}setTimeout(e,t){this.req.setTimeout(e,t);return this}_dump(){if(!this._dumped){this._dumped=true;this.removeAllListeners("data");this.resume()}}_read(){this.req&&this.req._request.resume()}}C=IncomingMessage;var A=C;var v={};v=e=>{const t={protocol:e.protocol,hostname:"string"===typeof e.hostname&&e.hostname.startsWith("[")?e.hostname.slice(1,-1):e.hostname,host:e.host,hash:e.hash,search:e.search,pathname:e.pathname,href:e.href,path:`${e.pathname||""}${e.search||""}`};"string"===typeof e.port&&0!==e.port.length&&(t.port=Number(e.port));(e.username||e.password)&&(t.auth=`${e.username||""}:${e.password||""}`);return t};var q=v;var R={};R=(e,t,s)=>{for(const o of s)e.on(o,((...e)=>t.emit(o,...e)))};var b=R;var H={};H=e=>{switch(e){case":method":case":scheme":case":authority":case":path":return true;default:return false}};var P=H;var x={};const makeError=(e,t,s)=>{x[t]=class NodeError extends e{constructor(...e){super("string"===typeof s?s:s(e));this.name=`${super.name} [${t}]`;this.code=t}}};makeError(TypeError,"ERR_INVALID_ARG_TYPE",(e=>{const t=e[0].includes(".")?"property":"argument";let s=e[1];const o=Array.isArray(s);o&&(s=`${s.slice(0,-1).join(", ")} or ${s.slice(-1)}`);return`The "${e[0]}" ${t} must be ${o?"one of":"of"} type ${s}. Received ${typeof e[2]}`}));makeError(TypeError,"ERR_INVALID_PROTOCOL",(e=>`Protocol "${e[0]}" not supported. Expected "${e[1]}"`));makeError(Error,"ERR_HTTP_HEADERS_SENT",(e=>`Cannot ${e[0]} headers after they are sent to the client`));makeError(TypeError,"ERR_INVALID_HTTP_TOKEN",(e=>`${e[0]} must be a valid HTTP token [${e[1]}]`));makeError(TypeError,"ERR_HTTP_INVALID_HEADER_VALUE",(e=>`Invalid value "${e[0]} for header "${e[1]}"`));makeError(TypeError,"ERR_INVALID_CHAR",(e=>`Invalid character in ${e[0]} [${e[1]}]`));var N={};var L=i.Buffer;var $=r;const k=e;const{Writable:I}=n;const{Agent:O,globalAgent:D}=w;const j=A;const V=q;const M=b;const z=P;const{ERR_INVALID_ARG_TYPE:F,ERR_INVALID_PROTOCOL:U,ERR_HTTP_HEADERS_SENT:G,ERR_INVALID_HTTP_TOKEN:B,ERR_HTTP_INVALID_HEADER_VALUE:W,ERR_INVALID_CHAR:K}=x;const{HTTP2_HEADER_STATUS:Y,HTTP2_HEADER_METHOD:J,HTTP2_HEADER_PATH:Q,HTTP2_METHOD_CONNECT:X}=k.constants;const Z=Symbol("headers");const ee=Symbol("origin");const te=Symbol("session");const se=Symbol("options");const oe=Symbol("flushedHeaders");const ne=Symbol("jobs");const re=/^[\^`\-\w!#$%&*+.|~]+$/;const ie=/[^\t\u0020-\u007E\u0080-\u00FF]/;class ClientRequest extends I{constructor(e,t,s){super({autoDestroy:false});const o="string"===typeof e||e instanceof URL;o&&(e=V(e instanceof URL?e:new URL(e)));if("function"===typeof t||void 0===t){s=t;t=o?e:{...e}}else t={...e,...t};if(t.h2session)this[te]=t.h2session;else if(false===t.agent)this.agent=new O({maxFreeSessions:0});else if("undefined"===typeof t.agent||null===t.agent)if("function"===typeof t.createConnection){this.agent=new O({maxFreeSessions:0});this.agent.createConnection=t.createConnection}else this.agent=D;else{if("function"!==typeof t.agent.request)throw new F("options.agent",["Agent-like Object","undefined","false"],t.agent);this.agent=t.agent}if(t.protocol&&"https:"!==t.protocol)throw new U(t.protocol,"https:");const n=t.port||t.defaultPort||this.agent&&this.agent.defaultPort||443;const r=t.hostname||t.host||"localhost";delete t.hostname;delete t.host;delete t.port;const{timeout:i}=t;t.timeout=void 0;this[Z]=Object.create(null);this[ne]=[];this.socket=null;this.connection=null;this.method=t.method||"GET";this.path=t.path;this.res=null;this.aborted=false;this.reusedSocket=false;if(t.headers)for(const[e,s]of Object.entries(t.headers))this.setHeader(e,s);t.auth&&!("authorization"in this[Z])&&(this[Z].authorization="Basic "+L.from(t.auth).toString("base64"));t.session=t.tlsSession;t.path=t.socketPath;this[se]=t;if(443===n){this[ee]=`https://${r}`;":authority"in this[Z]||(this[Z][":authority"]=r)}else{this[ee]=`https://${r}:${n}`;":authority"in this[Z]||(this[Z][":authority"]=`${r}:${n}`)}i&&this.setTimeout(i);s&&this.once("response",s);this[oe]=false}get method(){return this[Z][J]}set method(e){e&&(this[Z][J]=e.toUpperCase())}get path(){return this[Z][Q]}set path(e){e&&(this[Z][Q]=e)}get _mustNotHaveABody(){return"GET"===this.method||"HEAD"===this.method||"DELETE"===this.method}_write(e,t,s){if(this._mustNotHaveABody){s(new Error("The GET, HEAD and DELETE methods must NOT have a body"));return}this.flushHeaders();const callWrite=()=>this._request.write(e,t,s);this._request?callWrite():this[ne].push(callWrite)}_final(e){if(this.destroyed)return;this.flushHeaders();const callEnd=()=>{this._mustNotHaveABody?e():this._request.end(e)};this._request?callEnd():this[ne].push(callEnd)}abort(){if(!this.res||!this.res.complete){this.aborted||$.nextTick((()=>this.emit("abort")));this.aborted=true;this.destroy()}}_destroy(e,t){this.res&&this.res._dump();this._request&&this._request.destroy();t(e)}async flushHeaders(){if(this[oe]||this.destroyed)return;this[oe]=true;const e=this.method===X;const onStream=t=>{this._request=t;if(this.destroyed){t.destroy();return}e||M(t,this,["timeout","continue","close","error"]);const waitForEnd=e=>(...t)=>{this.writable||this.destroyed?this.once("finish",(()=>{e(...t)})):e(...t)};t.once("response",waitForEnd(((s,o,n)=>{const r=new j(this.socket,t.readableHighWaterMark);this.res=r;r.req=this;r.statusCode=s[Y];r.headers=s;r.rawHeaders=n;r.once("end",(()=>{if(this.aborted){r.aborted=true;r.emit("aborted")}else{r.complete=true;r.socket=null;r.connection=null}}));if(e){r.upgrade=true;this.emit("connect",r,t,L.alloc(0))?this.emit("close"):t.destroy()}else{t.on("data",(e=>{r._dumped||r.push(e)||t.pause()}));t.once("end",(()=>{r.push(null)}));this.emit("response",r)||r._dump()}})));t.once("headers",waitForEnd((e=>this.emit("information",{statusCode:e[Y]}))));t.once("trailers",waitForEnd(((e,t,s)=>{const{res:o}=this;o.trailers=e;o.rawTrailers=s})));const{socket:s}=t.session;this.socket=s;this.connection=s;for(const e of this[ne])e();this.emit("socket",this.socket)};if(this[te])try{onStream(this[te].request(this[Z]))}catch(e){this.emit("error",e)}else{this.reusedSocket=true;try{onStream(await this.agent.request(this[ee],this[se],this[Z]))}catch(e){this.emit("error",e)}}}getHeader(e){if("string"!==typeof e)throw new F("name","string",e);return this[Z][e.toLowerCase()]}get headersSent(){return this[oe]}removeHeader(e){if("string"!==typeof e)throw new F("name","string",e);if(this.headersSent)throw new G("remove");delete this[Z][e.toLowerCase()]}setHeader(e,t){if(this.headersSent)throw new G("set");if("string"!==typeof e||!re.test(e)&&!z(e))throw new B("Header name",e);if("undefined"===typeof t)throw new W(t,e);if(ie.test(t))throw new K("header content",e);this[Z][e.toLowerCase()]=t}setNoDelay(){}setSocketKeepAlive(){}setTimeout(e,t){const applyTimeout=()=>this._request.setTimeout(e,t);this._request?applyTimeout():this[ne].push(applyTimeout);return this}get maxHeadersCount(){if(!this.destroyed&&this._request)return this._request.session.localSettings.maxHeaderListSize}set maxHeadersCount(e){}}N=ClientRequest;var ae=N;var he={};const ce=u;he=e=>{let t=e.host;const s=e.headers&&e.headers.host;if(s)if(s.startsWith("[")){const e=s.indexOf("]");t=-1===e?s:s.slice(1,-1)}else t=s.split(":",1)[0];return ce.isIP(t)?"":t};var ue=he;var le={};const fe=a;const me=h;const de=c;const pe=o;const ge=ae;const ye=ue;const Se=q;const _e=new pe({maxSize:100});const Te=new Map;const installSocket=(e,t,s)=>{t._httpMessage={shouldKeepAlive:true};const onFree=()=>{e.emit("free",t,s)};t.on("free",onFree);const onClose=()=>{e.removeSocket(t,s)};t.on("close",onClose);const onRemove=()=>{e.removeSocket(t,s);t.off("close",onClose);t.off("free",onFree);t.off("agentRemove",onRemove)};t.on("agentRemove",onRemove);e.emit("free",t,s)};const resolveProtocol=async e=>{const t=`${e.host}:${e.port}:${e.ALPNProtocols.sort()}`;if(!_e.has(t)){if(Te.has(t)){const e=await Te.get(t);return e.alpnProtocol}const{path:s,agent:o}=e;e.path=e.socketPath;const n=de(e);Te.set(t,n);try{const{socket:r,alpnProtocol:i}=await n;_e.set(t,i);e.path=s;if("h2"===i)r.destroy();else{const{globalAgent:t}=me;const s=me.Agent.prototype.createConnection;o?o.createConnection===s?installSocket(o,r,e):r.destroy():t.createConnection===s?installSocket(t,r,e):r.destroy()}Te.delete(t);return i}catch(e){Te.delete(t);throw e}}return _e.get(t)};le=async(e,t,s)=>{("string"===typeof e||e instanceof URL)&&(e=Se(new URL(e)));if("function"===typeof t){s=t;t=void 0}t={ALPNProtocols:["h2","http/1.1"],...e,...t,resolveSocket:true};if(!Array.isArray(t.ALPNProtocols)||0===t.ALPNProtocols.length)throw new Error("The `ALPNProtocols` option must be an Array with at least one entry");t.protocol=t.protocol||"https:";const o="https:"===t.protocol;t.host=t.hostname||t.host||"localhost";t.session=t.tlsSession;t.servername=t.servername||ye(t);t.port=t.port||(o?443:80);t._defaultAgent=o?me.globalAgent:fe.globalAgent;const n=t.agent;if(n){if(n.addRequest)throw new Error("The `options.agent` object can contain only `http`, `https` or `http2` properties");t.agent=n[o?"https":"http"]}if(o){const e=await resolveProtocol(t);if("h2"===e){n&&(t.agent=n.http2);return new ge(t,s)}}return fe.request(t,s)};le.protocolCache=_e;var we=le;var Ce={};const Ee=e;const Ae=w;const ve=ae;const qe=A;const Re=we;const request=(e,t,s)=>new ve(e,t,s);const get=(e,t,s)=>{const o=new ve(e,t,s);o.end();return o};Ce={...Ee,ClientRequest:ve,IncomingMessage:qe,...Ae,request:request,get:get,auto:Re};var be=Ce;const He=Ce.ClientRequest,Pe=Ce.IncomingMessage,xe=Ce.request,Ne=Ce.get,Le=Ce.auto;export default be;export{He as ClientRequest,Pe as IncomingMessage,Le as auto,Ne as get,xe as request};

