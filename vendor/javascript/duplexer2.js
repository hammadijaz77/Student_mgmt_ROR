import e from"readable-stream";var r={};var t=e;function DuplexWrapper(e,r,p){if("undefined"===typeof p){p=r;r=e;e=null}t.Duplex.call(this,e);"function"!==typeof p.read&&(p=new t.Readable(e).wrap(p));this._writable=r;this._readable=p;this._waiting=false;var n=this;r.once("finish",(function(){n.end()}));this.once("finish",(function(){r.end()}));p.on("readable",(function(){if(n._waiting){n._waiting=false;n._read()}}));p.once("end",(function(){n.push(null)}));if(!e||"undefined"===typeof e.bubbleErrors||e.bubbleErrors){r.on("error",(function(e){n.emit("error",e)}));p.on("error",(function(e){n.emit("error",e)}))}}DuplexWrapper.prototype=Object.create(t.Duplex.prototype,{constructor:{value:DuplexWrapper}});DuplexWrapper.prototype._write=function _write(e,r,t){this._writable.write(e,r,t)};DuplexWrapper.prototype._read=function _read(){var e;var r=0;while(null!==(e=this._readable.read())){this.push(e);r++}0===r&&(this._waiting=true)};r=function duplex2(e,r,t){return new DuplexWrapper(e,r,t)};r.DuplexWrapper=DuplexWrapper;var p=r;const n=r.DuplexWrapper;export default p;export{n as DuplexWrapper};

