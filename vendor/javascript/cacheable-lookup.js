import e from"dns";import t from"util";import s from"os";var o={};const{V4MAPPED:i,ADDRCONFIG:a,ALL:r,promises:{Resolver:n},lookup:l}=e;const{promisify:h}=t;const c=s;const f=Symbol("cacheableLookupCreateConnection");const u=Symbol("cacheableLookupInstance");const m=Symbol("expires");const _="number"===typeof r;const verifyAgent=e=>{if(!(e&&"function"===typeof e.createConnection))throw new Error("Expected an Agent instance as the first argument")};const map4to6=e=>{for(const t of e)if(6!==t.family){t.address=`::ffff:${t.address}`;t.family=6}};const getIfaceInfo=()=>{let e=false;let t=false;for(const s of Object.values(c.networkInterfaces()))for(const o of s)if(!o.internal){"IPv6"===o.family?t=true:e=true;if(e&&t)return{has4:e,has6:t}}return{has4:e,has6:t}};const isIterable=e=>Symbol.iterator in e;const p={ttl:true};const y={all:true};class CacheableLookup{constructor({cache:e=new Map,maxTtl:t=Infinity,fallbackDuration:s=3600,errorTtl:o=.15,resolver:i=new n,lookup:a=l}={}){this.maxTtl=t;this.errorTtl=o;this._cache=e;this._resolver=i;this._dnsLookup=h(a);if(this._resolver instanceof n){this._resolve4=this._resolver.resolve4.bind(this._resolver);this._resolve6=this._resolver.resolve6.bind(this._resolver)}else{this._resolve4=h(this._resolver.resolve4.bind(this._resolver));this._resolve6=h(this._resolver.resolve6.bind(this._resolver))}this._iface=getIfaceInfo();this._pending={};this._nextRemovalTime=false;this._hostnamesToFallback=new Set;if(s<1)this._fallback=false;else{this._fallback=true;const e=setInterval((()=>{this._hostnamesToFallback.clear()}),1e3*s);e.unref&&e.unref()}this.lookup=this.lookup.bind(this);this.lookupAsync=this.lookupAsync.bind(this)}set servers(e){this.clear();this._resolver.setServers(e)}get servers(){return this._resolver.getServers()}lookup(e,t,s){if("function"===typeof t){s=t;t={}}else"number"===typeof t&&(t={family:t});if(!s)throw new Error("Callback must be a function.");this.lookupAsync(e,t).then((e=>{t.all?s(null,e):s(null,e.address,e.family,e.expires,e.ttl)}),s)}async lookupAsync(e,t={}){"number"===typeof t&&(t={family:t});let s=await this.query(e);if(6===t.family){const e=s.filter((e=>6===e.family));t.hints&i&&(_&&t.hints&r||0===e.length)?map4to6(s):s=e}else 4===t.family&&(s=s.filter((e=>4===e.family)));if(t.hints&a){const{_iface:e}=this;s=s.filter((t=>6===t.family?e.has6:e.has4))}if(0===s.length){const t=new Error(`cacheableLookup ENOTFOUND ${e}`);t.code="ENOTFOUND";t.hostname=e;throw t}return t.all?s:s[0]}async query(e){let t=await this._cache.get(e);if(!t){const s=this._pending[e];if(s)t=await s;else{const s=this.queryAndCache(e);this._pending[e]=s;try{t=await s}finally{delete this._pending[e]}}}t=t.map((e=>({...e})));return t}async _resolve(e){const wrap=async e=>{try{return await e}catch(e){if("ENODATA"===e.code||"ENOTFOUND"===e.code)return[];throw e}};const[t,s]=await Promise.all([this._resolve4(e,p),this._resolve6(e,p)].map((e=>wrap(e))));let o=0;let i=0;let a=0;const r=Date.now();for(const e of t){e.family=4;e.expires=r+1e3*e.ttl;o=Math.max(o,e.ttl)}for(const e of s){e.family=6;e.expires=r+1e3*e.ttl;i=Math.max(i,e.ttl)}a=t.length>0?s.length>0?Math.min(o,i):o:i;return{entries:[...t,...s],cacheTtl:a}}async _lookup(e){try{const t=await this._dnsLookup(e,{all:true});return{entries:t,cacheTtl:0}}catch(e){return{entries:[],cacheTtl:0}}}async _set(e,t,s){if(this.maxTtl>0&&s>0){s=1e3*Math.min(s,this.maxTtl);t[m]=Date.now()+s;try{await this._cache.set(e,t,s)}catch(e){this.lookupAsync=async()=>{const t=new Error("Cache Error. Please recreate the CacheableLookup instance.");t.cause=e;throw t}}isIterable(this._cache)&&this._tick(s)}}async queryAndCache(e){if(this._hostnamesToFallback.has(e))return this._dnsLookup(e,y);let t=await this._resolve(e);if(0===t.entries.length&&this._fallback){t=await this._lookup(e);0!==t.entries.length&&this._hostnamesToFallback.add(e)}const s=0===t.entries.length?this.errorTtl:t.cacheTtl;await this._set(e,t.entries,s);return t.entries}_tick(e){const t=this._nextRemovalTime;if(!t||e<t){clearTimeout(this._removalTimeout);this._nextRemovalTime=e;this._removalTimeout=setTimeout((()=>{this._nextRemovalTime=false;let e=Infinity;const t=Date.now();for(const[s,o]of this._cache){const i=o[m];t>=i?this._cache.delete(s):i<e&&(e=i)}Infinity!==e&&this._tick(e-t)}),e);this._removalTimeout.unref&&this._removalTimeout.unref()}}install(e){verifyAgent(e);if(f in e)throw new Error("CacheableLookup has been already installed");e[f]=e.createConnection;e[u]=this;e.createConnection=(t,s)=>{"lookup"in t||(t.lookup=this.lookup);return e[f](t,s)}}uninstall(e){verifyAgent(e);if(e[f]){if(e[u]!==this)throw new Error("The agent is not owned by this CacheableLookup instance");e.createConnection=e[f];delete e[f];delete e[u]}}updateInterfaceInfo(){const{_iface:e}=this;this._iface=getIfaceInfo();(e.has4&&!this._iface.has4||e.has6&&!this._iface.has6)&&this._cache.clear()}clear(e){e?this._cache.delete(e):this._cache.clear()}}o=CacheableLookup;o.default=CacheableLookup;var v=o;export default v;

